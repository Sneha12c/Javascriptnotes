// Decode message
function decode(mes){
  let str = "";
  let j=0, add=1;
  for(let i=0; i<mes[0].length; i++){
    str+= mes[j][i];
    j+= add;
    if(j==(mes.length-1)){
      add = -1;
    }
    if(j==0){
      add = 1;
    }
  }
  return str;
}

const arr = [['I', 'B' ,'C' ,'A' ,'L', 'K','A'],
['D', 'R', 'F', 'C', 'A', 'E', 'A'],[
'G' ,'H', 'O' ,'E', 'L','A' ,'D']];

console.log(decode(arr));

function uncompress(str){
  let i = 0, j = 0, cols = message[0]?.length;
  let decoded = '', step = 1;
  while(j < cols) {
    decoded += message[i][j];
    if(!message[i+step]){
      step *= -1;
    }
    i += step;
    j++;
  }
  return decoded;
}

// how does JavaScript’s Math.random() generate random numbers?
// JS doesn’t do anything, it’s up to the browser
// As of 2015, most browsers use an algorithm called xorshift128+
// The numbers generated by xorshift128+ aren’t really random, the sequence just take a long time 
// to repeat and they’re relatively evenly distributed over the expected range of values.

let state0 = 1;
let state1 = 2;

function xorshift() {
    let s1 = state0; 
    let s0 = state1; 
    state0 = s0;  

    /* SHIFTS - Just as with the seed values, the shift values (23, 17, and 26 here) must be 
    carefully chosen to lengthen the algorithm's period (the number of iterations before you 
    encounter repetition). Try changing these to see how the outcome is affected. */

    s1 ^= s1 << 23;  // SHIFT
    s1 ^= s1 >> 17;  // SHIFT
    s1 ^= s0;
    s1 ^= s0 >> 26;  // SHIFT
    state1 = s1;

   return state0 + state1;
   
}
